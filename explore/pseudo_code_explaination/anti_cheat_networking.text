In order to prevent achieving things other players would not have been able to achieve within the seame circumstances, it's acknowledge that the hacked client or a made from scratch client can send any possible signal, although a hacked client and a legit client may have similar signals during network jitter(legit or falsified) therefor in stead of punishment the server will take subtle evasive maneuvers by means of telling the client how it can update based on each action given per response.
Also at the expense of not having certain functionality such as true acceleration within a physics system instead the server will utilize a predictive acceleration system and the client will ask use a predictive acceleration system that incorporates corrective measures.
For instead from zero mph to five mph a heavy object could increase its speed one mph per three seconds and the server may not have received the decelerated signal there for the path along with changes will be reuploaded to the server in order to be authorized to achieve the position that the player has seen on their client. If the client knows they did not cheat the client will reject the servers path way(the one where the player kept accelerating until max speed was achieved) until the server has processed and authorized the clients version.
However if the server found in its simulated process that the clients version is impossible given the circumstances of the acceleration and momentum and weight then the server will send a "hard reject" signal with the pathway identification number and then the client will accept the servers model. In order to achieve this the client will have to non visually rewind a simulation of where the disagreement took place and then when it matches with the server then finally start rendering visually, the purpose of all that supposed excess work is for the client to sync a physics model as opposed to constantly communicating with the service. If the server says "no there's no way you couldn't have been doing anything else except accelerating straight all this time" then the clients visuals shouldn't be accelerijg from three miles per hour up to five mph it would have already been five mph and holding steady at a particular position.
When a correction happens changes shouldn't be sent in negation but when the player gestures a change should happen. 
If a player decelerated(w key pressed down) and the server said no to that and your still accelerating the w key should be virtually held down(accelerating still) until the player physically presses the w key and then let's go.

This can be done intelligently with other things it should apply to all actions, if casting magic requires a button press and then triggered on the release, don't force the player to hold down cast magic button and then release just assume it's cast is over until the next magic button is pressed.

Players like to trigger things in the ordered that they are pressed. A traditional event system first in first out method will not do because this usually means it is ignored if a networking error or jitter occurs.
So I mean technically it would be a "first in first out with incremental event verification"

So if a player pressed throw water and then light something on fire and a network jitter occurred ensure that it doesn't light on fire because it is wet.
This could probably allowed be accomplished with using TCP only however it may be found that UDP may be required or perhaps sudp (I think it's called) could be used where it's udp but it's a reliable in order type of method.
It should be mentioned that tcp can't solve fully the problems that were stated about forced network jitter during motion. A server must constantly decide what to commit to while accepting negotiating conditions with the client.
Please also don't succumb to pressure of negotiation tactics by hackers, in other words just make the game fun as possible the player will understand that if he/she misses out on something in order to ensure the game is fair the fairness of the game will then overcome their disappointment of missing out on loot(?) or gathering something they wanted.
For the most part only the motion could be targeted by hackers everything else is enforced by the service with out synchronization issues as it's just as predictable on the client side as it is on the service side allowing synchronization by predetemrination or formulatic(preside loaded table of meanings).
Enemies with a level 29 and tagged with a drop loot I'd of 44 will always drop twenty gold and could also come with a sync with service tag for anything that it doesn't drop as considered standard. Although a table will do just fine but then again this will likely be a webgl game so perhaps sync with service is more preferred to reduce download time at the cost of real-time streaming bandwidth constraints.
