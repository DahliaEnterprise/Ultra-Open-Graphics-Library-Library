<!doctype html>
<html>
  <head>
    <title>Adventure Game</title>
    <script type="text/javascript">
      //constant variables
      var math_pi = 3.141592;
      
      //open gl
      var canvas_handle = null;
      var opengles = null;
      
      //shaders
      var solid_color_vertex_shader = null;
      var solid_color_vertex_shader_source_code = null;
      var solid_color_fragment_shader = null;
      var solid_color_fragment_shader_source_code = null;
      var solid_color_shader_program = null;
      
      
      //models
        //combine vertex with rgba color
        var combine_vertex_and_rgba_color = null;
        
        //multicolored triangle
        var triangle_vertex = null;
        var triangle_rgba_color = null;
        var triangle_total_rows = null;
        var triangle_vertex_opengles = null;
        var triangle_and_color_metadata = { "position": { "x": 0.000000, "y": 0.000000, "z": 0.000000 },
                                            "rotation": { "x": 0.000000, "y": 0.000000, "z": 0.000000 },
                                            "scale": {  "x": 1.000000, "y": 1.000000, "z": 1.000000 },
                                           };
        var triangle_and_rgba_color_vertex_manipulated = null;
                                             
                                            
        
      //functions (header)
        //start main program
        var start_render = null;
        
        //tick game conditions
        var tick_game_conditions = null;
        var tick_game_conditions_last_tick_timestamp = null;
        
        //render frame
        var render_frame = null;
        var render_frame_interval = null;
        var render_frame_last_rendered_timestamp = null;
        
        //vertex manipulation
          //rotation
            //x
            
            //y
            
            //z axis
            var vertex_manipulation_rotate_z_axis = null;
            
          //scale
          
          //position
      
      /* Venmo: Shane-Betz1990 */
      combine_vertex_and_rgba_color = function(vertex, rgba_color, total_rows)
      {
        let size_of_vertex_and_color_rgba = ((3+4)*total_rows);
        let vertex_and_color_rgba = new Float32Array(size_of_vertex_and_color_rgba);
        
        let vertex_index = 0;
        let rgba_color_index = 0;
        let vertex_and_color_rgba_index = 0;
        let row = 0
        while(row < total_rows)
        {
          vertex_and_color_rgba[vertex_and_color_rgba_index] = vertex[vertex_index];
          vertex_and_color_rgba[vertex_and_color_rgba_index+1] = vertex[vertex_index+1];
          vertex_and_color_rgba[vertex_and_color_rgba_index+2] = vertex[vertex_index+2];
          
          vertex_and_color_rgba[vertex_and_color_rgba_index+3] = rgba_color[rgba_color_index];
          vertex_and_color_rgba[vertex_and_color_rgba_index+4] = rgba_color[rgba_color_index+1];
          vertex_and_color_rgba[vertex_and_color_rgba_index+5] = rgba_color[rgba_color_index+2];
          vertex_and_color_rgba[vertex_and_color_rgba_index+6] = rgba_color[rgba_color_index+3];
          
          vertex_and_color_rgba_index = vertex_and_color_rgba_index + 7;
          vertex_index = vertex_index + 3;
          rgba_color_index = rgba_color_index + 4;
          row = row + 1;
        }
        
        return vertex_and_color_rgba;
      }
      
      
      start_render = function()
      {
        //open gl
        canvas_handle = document.getElementById("canvas_for_opengles");
        
        opengles = canvas_handle.getContext("webgl2", {
                                                        antialias: true,
                                                        depth: true,
                                                        desynchronized: true,
                                                        powerPreference: "high-performance",
                                                        preserveDrawingBuffer: true
                                                      });
        opengles.viewportWidth = canvas_handle.width;
        opengles.viewportHeight = canvas_handle.height;
        
        //compile and thus have anticipated shaders ready.
        solid_color_vertex_shader = opengles.createShader(opengles.VERTEX_SHADER);
        solid_color_vertex_shader_source_code = "";
        solid_color_vertex_shader_source_code = solid_color_vertex_shader_source_code + "attribute vec4 position_of_vertex_to_colorize; \n";
        solid_color_vertex_shader_source_code = solid_color_vertex_shader_source_code + "attribute vec4 color_of_vertex_to_colorize; \n";
        solid_color_vertex_shader_source_code = solid_color_vertex_shader_source_code + "varying vec4 varying_color_of_vertex_to_colorize; \n";
        solid_color_vertex_shader_source_code = solid_color_vertex_shader_source_code + "void main() { \n";
        solid_color_vertex_shader_source_code = solid_color_vertex_shader_source_code + "  //colorize position.  \n";
        solid_color_vertex_shader_source_code = solid_color_vertex_shader_source_code + "  gl_Position = position_of_vertex_to_colorize; \n";
        solid_color_vertex_shader_source_code = solid_color_vertex_shader_source_code + "  varying_color_of_vertex_to_colorize = color_of_vertex_to_colorize;  \n";
        solid_color_vertex_shader_source_code = solid_color_vertex_shader_source_code + "} \n";
                  
        opengles.shaderSource(solid_color_vertex_shader , solid_color_vertex_shader_source_code);
              
        opengles.compileShader(solid_color_vertex_shader);
              
        solid_color_fragment_shader = opengles.createShader(opengles.FRAGMENT_SHADER);
        solid_color_fragment_shader_source_code = "";
        solid_color_fragment_shader_source_code = solid_color_fragment_shader_source_code + "precision mediump float;  \n";
        solid_color_fragment_shader_source_code = solid_color_fragment_shader_source_code + "varying vec4 varying_color_of_vertex_to_colorize; \n";
        solid_color_fragment_shader_source_code = solid_color_fragment_shader_source_code + "void main() { \n";
        solid_color_fragment_shader_source_code = solid_color_fragment_shader_source_code + "  //Define filter \n";
        solid_color_fragment_shader_source_code = solid_color_fragment_shader_source_code + "  gl_FragColor = varying_color_of_vertex_to_colorize; \n";
        solid_color_fragment_shader_source_code = solid_color_fragment_shader_source_code + "} \n";
                
        opengles.shaderSource(solid_color_fragment_shader, solid_color_fragment_shader_source_code);
                
        opengles.compileShader(solid_color_fragment_shader);
                
        solid_color_shader_program = opengles.createProgram();
        opengles.attachShader(solid_color_shader_program, solid_color_vertex_shader);
        opengles.attachShader(solid_color_shader_program, solid_color_fragment_shader);
        opengles.linkProgram(solid_color_shader_program);
      
        if(!opengles.getProgramParameter(solid_color_shader_program, opengles.LINK_STATUS))
        {
          alert("shader link process failed.");
        }
       
        //define triangle vertex.
       /* triangle_and_color_vertex = new Float32Array([
                                                       0.0, 0.5, 0.0, 1.0, 0.0, 0.0, 1.0,
                                                      -0.5, -0.5, 0.0, 0.0, 1.0, 0.0, 1.0,
                                                       0.5, -0.5, 0.0, 0.0, 0.0, 1.0, 1.0
                                                    ]);*/
            
            
         triangle_vertex = new Float32Array([
                                              0.0, 0.5, 0.0, 
                                              -0.5, -0.5, 0.0,
                                              0.5, -0.5, 0.0
                                             ]);
         triangle_rgba_color = new Float32Array([
                                                  1.0, 0.0, 0.0, 1.0,
                                                  0.0, 1.0, 0.0, 1.0,
                                                  0.0, 0.0, 1.0, 1.0
                                                ]);       
         triangle_total_rows = 3;
         
         
        
         //render frame loop
         render_frame_interval = 5000; //(1000 / 60); //target frame per second, 1000 milliseconds divided by target frame rate;
         render_frame_last_rendered_timestamp = Date.now();
         tick_game_conditions();
        
      }
      
      tick_game_conditions = function()
      {
      
        
        render_frame();
      
        setTimeout(tick_game_conditions, 1);
      }
      
      render_frame = function()
      {
        //determine when to begin render next frame.
        let current_timestamp_millisecond_format = Date.now();
        let time_passed_since_last_render = current_timestamp_millisecond_format - render_frame_last_rendered_timestamp;
        
        if(time_passed_since_last_render >= render_frame_interval)
        {
         render_frame_last_rendered_timestamp = Date.now();
        
         //prepare frame before clearing screen (prevents blank screens even if seemingly unnoticeable)
         triangle_and_color_metadata.rotation.z += 0.1;
         let triangle_vertex_manipulated = new Float32Array(triangle_vertex);
        
         triangle_vertex_manipulated = vertex_manipulation_rotate_z_axis(triangle_vertex_manipulated, triangle_total_rows, triangle_and_color_metadata.rotation.z);
       
         triangle_and_rgba_color_vertex_manipulated = combine_vertex_and_rgba_color(triangle_vertex_manipulated, triangle_rgba_color, triangle_total_rows);
         
         triangle_vertex_opengles = opengles.createBuffer();
         opengles.bindBuffer(opengles.ARRAY_BUFFER, triangle_vertex_opengles);
         opengles.bufferData(opengles.ARRAY_BUFFER, triangle_and_rgba_color_vertex_manipulated, opengles.STATIC_DRAW);
             
         triangle_vertex_opengles.positionSize = 3;
         triangle_vertex_opengles.colorSize = 4;
            
         triangle_vertex_opengles.numberOfItems = triangle_total_rows;

         opengles.bindBuffer(opengles.ARRAY_BUFFER, triangle_vertex_opengles);
            
            
         //Clear the viewport(screen) before drawing a new frame. (you will always do it this way, the only rare times you will add on to an already drawn frame is maybe an Operating System window(or UI) that goes on top of everything else and usually only when there is no alpha or moving objects).
         opengles.clearColor(0.0, 0.0, 0.0, 1.0);
         opengles.viewport(0, 0, opengles.viewportWidth, opengles.viewportHeight);
         opengles.clear(opengles.COLOR_BUFFER_BIT);
        
         //draw
         opengles.useProgram(solid_color_shader_program);
       
         solid_color_shader_program.vertexPositionAttribute = opengles.getAttribLocation(solid_color_shader_program, "position_of_vertex_to_colorize");
         
         solid_color_shader_program.vertexColorAttribute = opengles.getAttribLocation(solid_color_shader_program, "color_of_vertex_to_colorize");
          
         opengles.vertexAttribPointer(solid_color_shader_program.vertexPositionAttribute,  triangle_vertex_opengles.positionSize, opengles.FLOAT, false, 28, 0);
        
         opengles.vertexAttribPointer(solid_color_shader_program.vertexColorAttribute,  triangle_vertex_opengles.colorSize, opengles.FLOAT, false, 28, 12);
        
         opengles.enableVertexAttribArray(solid_color_shader_program.vertexPositionAttribute);
      
         opengles.enableVertexAttribArray(solid_color_shader_program.vertexColorAttribute);
        
         opengles.drawArrays(opengles.TRIANGLES, 0, triangle_vertex_opengles.numberOfItems);
        
        }
      }
      
      //vertex manipulation
        //z axis rotation
        vertex_manipulation_rotate_z_axis = function(vertex_to_manipulate, total_rows, z_degrees_to_apply)
        {
          let manipulated_z_vertex = new Float32Array(vertex_to_manipulate);
        
          //convert degrees to raidians.
          let amount_of_rotation_to_apply_in_radians = ((z_degrees_to_apply * math_pi) / 180.000000);
          
          let vertex_to_manipulate_index = 0;
          let row = 0;
          while(row < total_rows)
          {
            //todo here
            //next row
            vertex_to_manipulate_index = vertex_to_manipulate_index + 2;
            row = row + 1;
          }
          
          
          return manipulated_z_vertex;
        }
        
        
        
        
    </script>
  </head>
  <body onLoad="start_render();">
    <canvas id="canvas_for_opengles" width="800" height="800"></canvas>
  </body>
</html>
